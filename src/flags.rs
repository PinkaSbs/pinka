use std::path::PathBuf;

xflags::xflags! {
    src "src/flags.rs"

    cmd pinka {
        /// Config file path
        required -c, --config PATH: PathBuf
        /// Launch the nth server from the config file, default will launch the
        /// first one in the list.
        optional -s, --server N: usize

        cmd serve {}
        cmd raft {
            cmd dump {
                /// Start from index
                optional --from index: u64
            }
        }
        cmd repl {}
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Pinka {
    pub config: PathBuf,
    pub server: Option<usize>,
    pub subcommand: PinkaCmd,
}

#[derive(Debug)]
pub enum PinkaCmd {
    Serve(Serve),
    Raft(Raft),
    Repl(Repl),
}

#[derive(Debug)]
pub struct Serve;

#[derive(Debug)]
pub struct Raft {
    pub subcommand: RaftCmd,
}

#[derive(Debug)]
pub enum RaftCmd {
    Dump(Dump),
}

#[derive(Debug)]
pub struct Dump {
    pub from: Option<u64>,
}

#[derive(Debug)]
pub struct Repl;

impl Pinka {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
